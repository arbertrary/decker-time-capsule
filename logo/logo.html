<!DOCTYPE html>
<html lang="en">

<head>
  <title>Decker Logo</title>
  <meta charset="utf-8">
</head>

<body>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <script type="module">

    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.module.js';

    THREE.Cache.enabled = true;

    var container, hex;

    var camera, cameraTarget, scene, renderer;

    var group, textMesh1, textMesh2, textGeo, stack, materials;

    var firstLetter = true;

    var text = "D",

      height = 0.1,
      size = 70,
      hover = 30,

      curveSegments = 4,

      bevelThickness = 2,
      bevelSize = 1.5,
      bevelEnabled = false,

      font = undefined,

      fontName = "helvetiker", // helvetiker, optimer, gentilis, droid sans, droid serif
      fontWeight = "bold"; // normal bold

    var targetRotation = 0;
    var targetRotationOnPointerDown = 0;

    var pointerX = 0;
    var pointerXOnPointerDown = 0;

    var windowHalfX = window.innerWidth / 2;

    var fontIndex = 1;

    init();
    animate();

    function decimalToHex(d) {

      var hex = Number(d).toString(16);
      hex = "000000".substr(0, 6 - hex.length) + hex;
      return hex.toUpperCase();

    }

    function init() {

      container = document.createElement('div');
      document.body.appendChild(container);

      // CAMERA

      camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1500);
      camera.position.set(0, 160, 70);

      cameraTarget = new THREE.Vector3(0, 160, 0);

      // SCENE

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      scene.fog = new THREE.Fog(0x000000, 250, 1400);

      // LIGHTS

      var dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
      dirLight.position.set(0, 0, 1).normalize();
      scene.add(dirLight);

      materials = [
        new THREE.MeshBasicMaterial({color: 0x666666, side: THREE.DoubleSide}), // front
        new THREE.MeshBasicMaterial({color: 0x666666, side: THREE.DoubleSide}) // side
      ];

      group = new THREE.Group();
      group.position.y = 100;

      let makePlane = (color, z) => {
        var geometry = new THREE.PlaneGeometry(25,80);
        var material = new THREE.MeshBasicMaterial({color: color, side: THREE.DoubleSide});
        var plane = new THREE.Mesh(geometry, material);
        plane.position.z = z;
        return plane;
      };

      stack = new THREE.Group();
      let p1 = makePlane("#F09837", 0);
      let p2 = makePlane("#2D4D82", 5);
      let p3 = makePlane("#EA4034", 10);
      stack.add(p1, p2, p3);
      stack.position.y = 60;
      stack.position.x = 3;
      stack.rotation.x = -1.3;
      stack.rotation.y = -0.4;
      stack.rotation.z = 0.6;

      group.add(stack);
      scene.add(group);

      loadFont();

      var plane = new THREE.Mesh(
        new THREE.PlaneBufferGeometry(10000, 10000),
        new THREE.MeshBasicMaterial({color: 0xffffff, opacity: 0.5, transparent: true})
      );
      plane.position.y = 100;
      plane.rotation.x = - Math.PI / 2;
      // scene.add(plane);

      // RENDERER

      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      // EVENTS

      container.style.touchAction = 'none';
      container.addEventListener('pointerdown', onPointerDown, false);

      window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {

      windowHalfX = window.innerWidth / 2;

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }

    //

    function boolToNum(b) {

      return b ? 1 : 0;

    }

    function loadFont() {

      var loader = new THREE.FontLoader();
      loader.load('fonts/' + fontName + '_' + fontWeight + '.typeface.json', function (response) {

        font = response;

        refreshText();

      });

    }

    function createText() {

      textGeo = new THREE.TextGeometry(text, {

        font: font,

        size: size,
        height: height,
        curveSegments: curveSegments,

        bevelThickness: bevelThickness,
        bevelSize: bevelSize,
        bevelEnabled: bevelEnabled

      });

      textGeo.computeBoundingBox();
      textGeo.computeVertexNormals();

      var triangle = new THREE.Triangle();

      // "fix" side normals by removing z-component of normals for side faces
      // (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)

      if (!bevelEnabled) {

        var triangleAreaHeuristics = 0.1 * (height * size);

        for (var i = 0; i < textGeo.faces.length; i++) {

          var face = textGeo.faces[i];

          if (face.materialIndex == 1) {

            for (var j = 0; j < face.vertexNormals.length; j++) {

              face.vertexNormals[j].z = 0;
              face.vertexNormals[j].normalize();

            }

            var va = textGeo.vertices[face.a];
            var vb = textGeo.vertices[face.b];
            var vc = textGeo.vertices[face.c];

            var s = triangle.set(va, vb, vc).getArea();

            if (s > triangleAreaHeuristics) {

              for (var j = 0; j < face.vertexNormals.length; j++) {

                face.vertexNormals[j].copy(face.normal);

              }

            }

          }

        }

      }

      var centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);

      textGeo = new THREE.BufferGeometry().fromGeometry(textGeo);

      textMesh1 = new THREE.Mesh(textGeo, materials);

      textMesh1.position.x = centerOffset;
      textMesh1.position.y = hover;
      textMesh1.position.z = 0;

      textMesh1.rotation.x = 0;
      textMesh1.rotation.y = Math.PI * 2;

      group.add(textMesh1);

    }

    function refreshText() {

      group.remove(textMesh1);

      if (!text) return;

      createText();

    }

    function onPointerDown(event) {

      if (event.isPrimary === false) return;

      pointerXOnPointerDown = event.clientX - windowHalfX;
      targetRotationOnPointerDown = targetRotation;

      document.addEventListener('pointermove', onPointerMove, false);
      document.addEventListener('pointerup', onPointerUp, false);

    }

    function onPointerMove(event) {

      if (event.isPrimary === false) return;

      pointerX = event.clientX - windowHalfX;

      targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;

    }

    function onPointerUp() {

      if (event.isPrimary === false) return;

      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);

    }

    //

    function animate() {

      requestAnimationFrame(animate);

      render();
    }

    function render() {

      group.rotation.y += (targetRotation - group.rotation.y) * 0.05;

      camera.lookAt(cameraTarget);

      renderer.clear();
      renderer.render(scene, camera);

    }

  </script>

</body>

</html>
